---
week: 4주차
---

# 모던 자바스크립트 Deep Dive CH16. 프로퍼티 어트리뷰트

## 목차

- [내부 슬롯과 내부 메서드](#내부-슬롯과-내부-메서드)
- [프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체](#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체)
- [데이터 프로퍼티와 접근자 프로퍼티](#데이터-프로퍼티와-접근자-프로퍼티)
  - [1. 데이터 프로퍼티](#1-데이터-프로퍼티)
  - [2. 접근자 프로퍼티](#2-접근자-프로퍼티)
- [프로퍼티 정의](#프로퍼티-정의)
- [객체 변경 방지](#객체-변경-방지)
  - [1. 객체 확장 금지](#1-객체-확장-금지)
  - [2. 객체 밀봉](#2-객체-밀봉)
  - [3. 객체 동결](#3-객체-동결)


## 내부 슬롯과 내부 메서드

**내부 슬롯**<sup>internal slot</sup>과 **내부 메서드**<sup>internal method</sup>는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 **의사 프로퍼티**<sup>pseudo property</sup>와 **의사 메서드**<sup>pseudo method</sup>이다. ECMAScript 사양에서 이중 대괄호(`[[]]`)로 감싼 이름들이 내부 슬롯과 내부 메서드이며, 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작한다. 

공개된 객체의 프로퍼티는 아니기 때문에 개발자가 직접 접근할 수는 없지만, 일부는 간접적으로 접근할 수 있는 수단을 제공한다.

```js
// [[Prototype]]: 모든 객체가 가진 내부 슬롯
const x = {};

x.[[Prototype]]; // 직접 접근 불가
x.__proto__; // __proto__를 통해 간접적 접근
```

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

> ⭐ **프로퍼티의 상태**
>
> 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말함
> > 내부 슬롯(프로퍼티 어트리뷰트): `[[Value]]`, `[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`

프로퍼티 어트리뷰트는 내부 슬롯이라 직접 접근할 수는 없지만 `Object.getOwnPropertyDescriptor` 메서드를 사용해 간접적으로 확인이 가능하다.

```js
const x = { num: 36 };

// Object.getOwnPropertyDescriptor
// 첫 번째 매개변수: 객체의 참조
// 두 번째 매개변수: 프로퍼티 키(문자열)
Object.getOwnPropertyDescriptor(x, 'num');
// 프로퍼티 디스크립터 객체(프로퍼티 어트리뷰트 정보 제공) 반환
// {value: 36, writable: true, enumerable: true, configurable: true}
```

## 데이터 프로퍼티와 접근자 프로퍼티

### 1. 데이터 프로퍼티

키와 값으로 구성된 일반적인 프로퍼티로 아래와 같은 프로퍼티 어트리뷰트를 갖는다. 이는 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의된다.

| 프로퍼티<br>어트리뷰트 | 프로퍼티 디스크립터<br>객체의 프로퍼티 | 설명                                                                                                                                                                                                                    |
| :--------------------: | :------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|      `[[Value]]`       |                 value                  | - 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값<br>- 프로퍼티 키를 통해 프로퍼티 값을 변경하면 `[[Value]]`에 값을 재할당<br>프로퍼티가 없는 경우 프로퍼티 동적 생성 후, 생성된 프로퍼티의 `[[Value]]`에 값 저장 |
|     `[[Writable]]`     |                writable                | - 프로퍼티 값의 변경 가능 여부, 불리언<br>- `false`인 경우 해당 프로퍼티의 `[[Value]]`값 변경 불가(읽기 전용 프로퍼티)                                                                                                  |
|    `[[Enumerable]]`    |               enumerable               | - 프로퍼티의 열거 가능 여부, 불리언<br>- `false`인 경우 `for...in`문이나 `Object.keys` 메서드 등으로 열거 불가능                                                                                                        |
|   `[[Configurable]]`   |              configurable              | - 프로퍼티의 재정의 가능 여부, 불리언<br>- `false`인 경우 프로퍼티 삭제, 프로퍼티 어트리뷰트 값 변경이 금지<br>- *`[[Writable]]`이 `true`인 경우 `[[Value]]`의 변경과 `[[Writable]]`을 `false`로 변경하는 것은 허용*    |

### 2. 접근자 프로퍼티

자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티로 아래와 같은 프로퍼티 어트리뷰트를 갖는다.

| 프로퍼티<br>어트리뷰트 | 프로퍼티 디스크립터<br>객체의 프로퍼티 | 설명                                                                                                                                                                                                                |
| :--------------------: | :------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|       `[[Get]]`        |                  get                   | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수<br>- 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 `[[Get]]`의 값(`getter` 함수) 호출, 결과가 프로퍼티 값으로 반환   |
|       `[[Set]]`        |                  set                   | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수<br>- 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 `[[Set]]`의 값(`setter` 함수) 호출, 결과가 프로퍼티 값으로 저장 |
|    `[[Enumerable]]`    |               enumerable               | - 데이터 프로퍼티와 동일                                                                                                                                                                                            |
|   `[[Configurable]]`   |              configurable              | - 데이터 프로퍼티와 동일                                                                                                                                                                                            |

## 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말하며 `Object.defineProperty` 메서드를 사용한다.

```js
const x = {};

// Object.defineProperty
// 인수로 (객체의 참조, 데이터 프로퍼티의 키(문자열), 프로퍼티 디스크립터 객체) 전달
// a. 데이터 프로퍼티 정의
Object.defineProperty(x, 'num', {
  value: 36,
  writable: true,
  enumerable: true,
  configurable: true
});

// b. 접근자 프로퍼티 정의
Object.defineProperty(x, 'numOfX', {
  get() {
    return this.num;
  },
  set(num) {
    this.num = num;
  },
  enumerable: true,
  configurable: true
});


const y = {};

// Object.defineProperties
// 여러 개의 프로퍼티를 한 번에 정의
Object.defineProperties(y, {
  // 데이터 프로퍼티 정의
  firstName: {
    value: 'tae',
    writable: true,
    enumerable: true,
    configurable: true
  },
  lastName: {
    value: 'kim',
    writable: true,
    enumerable: true,
    configurable: true
  },
  // 접근자 프로퍼티 정의
  fullName: {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    set(name) {
      [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable: true,
    configurable: true
  }
});
```

프로퍼티를 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있는데, 이 경우 아래와 같은 기본값이 적용된다.

* `value`(`[[Value]]`): undefined
* `get`(`[[Get]]`): undefined
* `set`(`[[Set]]`): undefined
* `writable`(`[[Writable]]`): false
* `enumerable`(`[[Enumerable]]`): false
* `configurable`(`[[Configurable]]`): false

## 객체 변경 방지

자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공하는데, 이들은 객체의 변경을 금지하는 강도가 다르다.

| 구분           | 메서드                     | 확인 메서드           | 프로퍼티<br>추가 | 프로퍼티<br>삭제 | 프로퍼티<br>값 읽기 | 프로퍼티<br>값 쓰기 | 프로퍼티 어트리뷰트<br>재정의 |
| :------------- | :------------------------- | :-------------------- | :--------------: | :--------------: | :-----------------: | :-----------------: | :---------------------------: |
| 객체 확장 금지 | `Object.preventExtensions` | `Object.isExtensible` |        Ｘ        |        Ｏ        |         Ｏ          |         Ｏ          |              Ｏ               |
| 객체 밀봉      | `Object.seal`              | `Object.isSealed`     |        Ｘ        |        Ｘ        |         Ｏ          |         Ｏ          |              Ｘ               |
| 객체 동결      | `Object.freeze`            | `Object.isFrozen`     |        Ｘ        |        Ｘ        |         Ｏ          |         Ｘ          |              Ｘ               |

### 1. 객체 확장 금지

확장이 금지된 객체는 프로퍼티 추가(프로퍼티 동적 추가, `Object.defineProperty` 메서드)가 금지된다.

### 2. 객체 밀봉

객체 밀봉이란 프로퍼티 추가/삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다. 따라서 밀봉된 객체는 **읽기와 쓰기**만 가능하다.

### 3. 객체 동결

객체 동결은 프로퍼티 추가/삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 따라서 동결된 객체는 **읽기**만 가능하다.

> ⭐ **불변 객체**
>
> 위 3가지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다. 중첩 객체까지 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 모든 프로퍼티에 대해 재귀적으로 `Object.freeze` 메서드를 호출해야 한다.
>
> ```js
> function deepFreeze(target) {
>   // 동결되지 않은 객체만 동결
>   if (target && typeof target === 'object' && !Object.isFrozen(target)) {
>     // 모든 프로퍼티를 순회하며 재귀적으로 동결
>     // Object.keys: 객체의 프로퍼티 키를 배열로 반환
>     // forEach: 배열 순회, 각 요소에 대해 콜백 함수 실행
>     Object.keys(target).forEach(key => deepFreeze(target[key]));
>   }
>   return target;
> }
> ```

